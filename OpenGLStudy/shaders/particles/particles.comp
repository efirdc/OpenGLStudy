#version 440

layout (local_size_x = 512) in;

#include "../noise/hash.glsl"
#include "particles_common.glsl"

void main()
{
	uint particleIndex = gl_GlobalInvocationID.x;
	uint particleID = particleIndex + 1;

	vec3 velocity = sourceParticles[particleIndex].velocity;
	vec3 position = sourceParticles[particleIndex].position;

	if (resetParticles)
	{
		position = hash31(particleIndex + 252354) * vec3(simulationSize);
		velocity = vec3(0);
		destParticles[particleIndex].position = position;
		destParticles[particleIndex].velocity = velocity;
		return;
	}

	if (isSorted(position, particleID) < 0)
	{
		destParticles[particleIndex].position = position;
		destParticles[particleIndex].velocity = velocity;
		return;
	}
		
	float dt = 1.0 / 60.0 * timestep;

	ivec3 particleCell = ivec3(position);

	int neighborCount = 0;
	vec3 avoidance = vec3(0);
	vec3 alignment = vec3(0);
	
	for (int i = -1; i < 2; i++)
	for (int j = -1; j < 2; j++)
	for (int k = -1; k < 2; k++)
	for (int p = 0; p < PARTICLES_PER_CELL; p++)
	{
		ivec3 storedParticleCell = (particleCell + ivec3(i, j, k)) * ivec3(8, 1, 1) + ivec3(p, 0, 0);
		uint storedParticleID = texelFetch(particleMapSampler, storedParticleCell, 0).x;
		if (storedParticleID == NULL_ID)
			break;
		if (storedParticleID == particleID)
			continue;


		vec3 storedParticlePos = sourceParticles[storedParticleID - 1].position;
		if (position == storedParticlePos)
			storedParticlePos += (hash31(particleIndex + storedParticleID) * 2 - 1) * 0.01;
		vec3 delta = position - storedParticlePos;
		float deltaLength = length(delta);

		if (deltaLength > 1.0)
			continue;

		neighborCount += 1;
		float boundary = 0.95;
		float attraction =  200 *(-deltaLength + boundary);
		float repulsion = max(0.0, 100 * (boundary - deltaLength) / deltaLength);

		avoidance += delta / deltaLength * (deltaLength < boundary ? repulsion : attraction);
		alignment += sourceParticles[storedParticleID - 1].velocity;
	}

	velocity += avoidance * dt;
	if (neighborCount > 0)
		velocity += alignment / neighborCount * dt * 0.4;

	// Square magnitude drag
	velocity -= velocity * length(velocity) * dt * 0.2;

	// Gravity
	velocity += vec3(0, -5.0, 0) * dt;

	// Apply velocity
	position += velocity * dt;

	// Boundary condition
	vec3 boundary = vec3(simulationSize - 1);
	for (int i = 0; i < 3; i++)
	{
		if (position[i] < 0.0 || position[i] > boundary[i])
		{
			position[i] = clamp(position[i], 0.0, boundary[i]);
			velocity[i] *= -1.0;
		}
	}

	destParticles[particleIndex].position = position;
	destParticles[particleIndex].velocity = velocity;
}