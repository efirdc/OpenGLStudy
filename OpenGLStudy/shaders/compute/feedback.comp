#version 440 core
layout(local_size_x = 8, local_size_y = 8, local_size_z = 8) in;

#define SAFE_MODE 0
#if SAFE_MODE == 2
	#define COHERENT coherent
	#define BARRIER //
#elif SAFE_MODE == 1
	#define COHERENT 
	#define BARRIER memoryBarrierBuffer();
#else
	#define COHERENT
	#define BARRIER //
#endif


layout(binding = 0, rgba32f) COHERENT uniform image3D fluidImage;
layout(binding = 2, rgba32f) COHERENT uniform image3D curlImage;
layout(binding = 3, rgba32f) COHERENT uniform image3D densityImage;

layout(binding = 0) uniform sampler3D fluidSampler;
layout(binding = 2) uniform sampler3D curlSampler;
layout(binding = 3) uniform sampler3D densitySampler;

uniform float time;
uniform float deltaTime;
uniform float timeScale;
uniform mat4 view;

struct FluidSplat { 
	float radius, velocity, pressure, density;
};

uniform ivec3 fluidSize;
uniform int numPressureIterations;
uniform float velocityDissipation;
uniform float densityDissipation;
uniform float vorticityScalar;
uniform FluidSplat mouseSplat;
uniform FluidSplat externalSplat;

#define IMAGE_LOAD_ADJACENT(image, coords, left, right, top, bottom, front, back)\
{\
	left = imageLoad(image, icoords + ivec3(-1, 0, 0));\
	right = imageLoad(image, icoords + ivec3(1, 0, 0));\
	top = imageLoad(image, icoords + ivec3(0, 1, 0));\
	bottom = imageLoad(image, icoords + ivec3(0, -1, 0));\
	front = imageLoad(image, icoords + ivec3(0, 0, 1));\
	back = imageLoad(image, icoords + ivec3(0, 0, -1));\
}

#define IMAGE_LOAD_ADJACENT_CLAMP_TO_EDGE(image, coords, left, right, top, bottom, front, back)\
{\
	left = imageLoad(image, clamp(icoords + ivec3(-1, 0, 0), ivec3(0), fluidSize));\
	right = imageLoad(image, clamp(icoords + ivec3(1, 0, 0), ivec3(0), fluidSize));\
	top = imageLoad(image, clamp(icoords + ivec3(0, 1, 0), ivec3(0), fluidSize));\
	bottom = imageLoad(image, clamp(icoords + ivec3(0, -1, 0), ivec3(0), fluidSize));\
	front = imageLoad(image, clamp(icoords + ivec3(0, 0, 1), ivec3(0), fluidSize));\
	back = imageLoad(image, clamp(icoords + ivec3(0, 0, -1), ivec3(0), fluidSize));\
}

float gauss(vec3 p, float r)
{
  return exp(-dot(p, p) / r);
}

void main()
{
	vec3 coords = vec3(gl_GlobalInvocationID.xyz);
	ivec3 icoords = ivec3(gl_GlobalInvocationID.xyz);
	
	// Advection
	vec4 center, left, right, top, bottom, front, back;
	center = texelFetch(fluidSampler, icoords, 0);
	//IMAGE_LOAD_ADJACENT(fluidImage, icoords, left, right, top, bottom, front, back)
	float dt = min(deltaTime, 1.0 / 60.0);
	vec3 backCoords = ((coords + 0.5) - center.xyz * dt * timeScale) + vec3(0.0, -0.01, 0.0);
	vec4 backFluid = texture(fluidSampler, backCoords / vec3(fluidSize));
	vec4 density = texture(densitySampler, backCoords / vec3(fluidSize));
	center.xyz = backFluid.xyz;
	center.xyz *= velocityDissipation;

	// External forces
	vec3 h33 = vec3(0.23, 0.3, 0.35);
	vec3 asd = sin(time * 0.5 * (h33 * 2 - 1)) ;
	vec3 deltaCenter = coords - (asd * 0.2 + 0.5) * vec3(fluidSize);
	float splat = gauss(deltaCenter, externalSplat.radius);
	center.xyz += asd * splat * externalSplat.velocity;
	center.w += splat * externalSplat.pressure;
	density += splat * externalSplat.density;
	density *= densityDissipation;
	BARRIER
	imageStore(densityImage, icoords, density);
	imageStore(fluidImage, icoords, center);
	BARRIER

	// Vorticity
	IMAGE_LOAD_ADJACENT(fluidImage, icoords, left, right, top, bottom, front, back)
	vec3 curl = vec3(
		top.z - front.y - bottom.z + back.z, 
		front.x - right.z - back.x + left.z,
		right.y - top.x - left.y + bottom.x);
	BARRIER
	imageStore(curlImage, icoords, vec4(curl, length(curl)));
	BARRIER
	IMAGE_LOAD_ADJACENT(curlImage, icoords, left, right, top, bottom, front, back)
	vec3 eta = vec3( right.w - left.w, top.w - bottom.w, front.w - back.w) * 0.5;
	eta = length(eta) > 0.001 ? normalize(eta) : vec3(0);
	vec3 force = vec3(eta.y * curl.z - eta.z * curl.y, 
					  eta.z * curl.x - eta.x * curl.z,
					  eta.x * curl.y - eta.y * curl.x);
	center.xyz += force * vorticityScalar;
	BARRIER
	imageStore(fluidImage, icoords, center);
	BARRIER
	
	// Divergence, 1 pressure iteration
	IMAGE_LOAD_ADJACENT(fluidImage, icoords, left, right, top, bottom, front, back)
	float divergence = (right.x - left.x + top.y - bottom.y + front.z - back.z) * 0.5;
	center.w = (left.w + right.w + top.w + bottom.w + front.w + back.w - divergence) / 6.0;
	BARRIER
	imageStore(fluidImage, icoords, center);
	BARRIER
	
	// Additional pressure iterations
	for (int i = 0; i < numPressureIterations; i++)
	{
		IMAGE_LOAD_ADJACENT(fluidImage, icoords, left, right, top, bottom, front, back)
		center.w = (left.w + right.w + top.w + bottom.w + front.w + back.w - divergence) / 6.0;
		BARRIER
		imageStore(fluidImage, icoords, center);
		BARRIER
	}

	// Subtract pressure gradient
	IMAGE_LOAD_ADJACENT(fluidImage, icoords, left, right, top, bottom, front, back)
	vec3 pressureGradient = vec3(right.w - left.w, top.w - bottom.w, front.w - back.w) * 0.5;
	center.xyz -= pressureGradient;
	BARRIER
	imageStore(fluidImage, icoords, center);
	BARRIER
}

